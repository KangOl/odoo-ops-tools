#!/usr/bin/env bash
set -euo pipefail
if [[ -n "${DEBUG:-}" ]]; then
    set -x
fi

# ARG_HELP([Show the manifest of an Odoo module in a given version])
# ARG_OPTIONAL_SINGLE([remote],[r],[remote to use],[origin])
# ARG_POSITIONAL_SINGLE([module],[Module])
# ARG_POSITIONAL_SINGLE([branch],[Branch],[HEAD])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die() {
    local _ret="${2:-1}"
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    echo "$1" >&2
    exit "${_ret}"
}

begins_with_short_option() {
    local first_option all_short_options='hr'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_branch="HEAD"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_remote="origin"

print_help() {
    printf '%s\n' "Show the manifest of an Odoo module in a given version"
    printf 'Usage: %s [-h|--help] [-r|--remote <arg>] <module> [<branch>]\n' "$0"
    printf '\t%s\n' "<module>: Module"
    printf '\t%s\n' "<branch>: Branch (default: 'HEAD')"
    printf '\t%s\n' "-h, --help: Prints help"
    printf '\t%s\n' "-r, --remote: remote to use (default: 'origin')"
}

parse_commandline() {
    _positionals_count=0
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
            -h | --help)
                print_help
                exit 0
                ;;
            -h*)
                print_help
                exit 0
                ;;
            -r | --remote)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_remote="$2"
                shift
                ;;
            --remote=*)
                _arg_remote="${_key##--remote=}"
                ;;
            -r*)
                _arg_remote="${_key##-r}"
                ;;
            *)
                _last_positional="$1"
                _positionals+=("$_last_positional")
                _positionals_count=$((_positionals_count + 1))
                ;;
        esac
        shift
    done
}

handle_passed_args_count() {
    local _required_args_string="'module'"
    test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
    local _positional_name _shift_for=$1
    _positional_names="_arg_module _arg_branch "

    shift "$_shift_for"
    for _positional_name in ${_positional_names}; do
        test $# -gt 0 || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

if [[ $_arg_branch != "HEAD" ]]; then
    _arg_branch="$_arg_remote/$_arg_branch"
fi

cd "$(git rev-parse --show-toplevel)"

# shellcheck disable=SC2154
blob=$(git ls-tree "${_arg_branch}" -- {.,addons,{openerp,odoo}/addons}/"${_arg_module}"/__{terp,openerp,manifest}__.py 2>/dev/null | awk '{print $3}')

if [[ -z $blob ]]; then
    die "Unknown module '${_arg_module}' in ${_arg_branch}"
fi
git show "$blob"

# ] <-- needed because of Argbash
